<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>libhcs: pcs.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libhcs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_48c5b484643111026a9a8bba13c9f7ed.html">libhcs</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pcs.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The Paillier scheme is a scheme which provides homormorphic addition, and limited multiplication on encrypted data.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;gmp.h&gt;</code><br />
<code>#include &quot;<a class="el" href="hcs__random_8h_source.html">hcs_random.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for pcs.h:</div>
<div class="dyncontent">
<div class="center"><img src="pcs_8h__incl.png" border="0" usemap="#pcs_8h" alt=""/></div>
<map name="pcs_8h" id="pcs_8h">
<area shape="rect" id="node3" href="hcs__random_8h.html" title="Provides secure random state for use in functions which require random values. " alt="" coords="28,80,132,107"/></map>
</div>
</div>
<p><a href="pcs_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcs__public__key.html">pcs_public_key</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public key for use in the Paillier system.  <a href="structpcs__public__key.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcs__private__key.html">pcs_private_key</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private key for use in the Paillier system.  <a href="structpcs__private__key.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3035af644a94bda8ea01eb81a1781ba4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcs__public__key.html">pcs_public_key</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcs_8h.html#a3035af644a94bda8ea01eb81a1781ba4">pcs_init_public_key</a> (void)</td></tr>
<tr class="memdesc:a3035af644a94bda8ea01eb81a1781ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a <a class="el" href="structpcs__public__key.html" title="Public key for use in the Paillier system. ">pcs_public_key</a> and return a pointer to the newly created structure.  <a href="#a3035af644a94bda8ea01eb81a1781ba4">More...</a><br /></td></tr>
<tr class="separator:a3035af644a94bda8ea01eb81a1781ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d620d36edbd87870d9ee42ed4f907e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcs__private__key.html">pcs_private_key</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcs_8h.html#af4d620d36edbd87870d9ee42ed4f907e">pcs_init_private_key</a> (void)</td></tr>
<tr class="memdesc:af4d620d36edbd87870d9ee42ed4f907e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a <a class="el" href="structpcs__private__key.html" title="Private key for use in the Paillier system. ">pcs_private_key</a> and return a pointer to the newly created structure.  <a href="#af4d620d36edbd87870d9ee42ed4f907e">More...</a><br /></td></tr>
<tr class="separator:af4d620d36edbd87870d9ee42ed4f907e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6bbd4593663ba9dadd3fe7cafd0074"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcs_8h.html#aad6bbd4593663ba9dadd3fe7cafd0074">pcs_generate_key_pair</a> (<a class="el" href="structpcs__public__key.html">pcs_public_key</a> *pk, <a class="el" href="structpcs__private__key.html">pcs_private_key</a> *vk, <a class="el" href="structhcs__random.html">hcs_random</a> *hr, const unsigned long bits)</td></tr>
<tr class="memdesc:aad6bbd4593663ba9dadd3fe7cafd0074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a key pair with modulus size <code>bits</code>.  <a href="#aad6bbd4593663ba9dadd3fe7cafd0074">More...</a><br /></td></tr>
<tr class="separator:aad6bbd4593663ba9dadd3fe7cafd0074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a417767dc3e6332b701e0391eabc13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcs_8h.html#a12a417767dc3e6332b701e0391eabc13">pcs_encrypt</a> (<a class="el" href="structpcs__public__key.html">pcs_public_key</a> *pk, <a class="el" href="structhcs__random.html">hcs_random</a> *hr, mpz_t rop, mpz_t plain1)</td></tr>
<tr class="memdesc:a12a417767dc3e6332b701e0391eabc13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypt a value <code>plain1</code>, and set <code>rop</code> to the encrypted result.  <a href="#a12a417767dc3e6332b701e0391eabc13">More...</a><br /></td></tr>
<tr class="separator:a12a417767dc3e6332b701e0391eabc13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20bd765e28b001cbaf059b1d2b677444"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcs_8h.html#a20bd765e28b001cbaf059b1d2b677444">pcs_encrypt_r</a> (<a class="el" href="structpcs__public__key.html">pcs_public_key</a> *pk, mpz_t rop, mpz_t plain1, mpz_t r)</td></tr>
<tr class="memdesc:a20bd765e28b001cbaf059b1d2b677444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypt a value <code>plain1</code>, and set <code>rop</code> to the encrypted result.  <a href="#a20bd765e28b001cbaf059b1d2b677444">More...</a><br /></td></tr>
<tr class="separator:a20bd765e28b001cbaf059b1d2b677444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b3c0fb74b50df7c2c7c9c9802d645f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcs_8h.html#a65b3c0fb74b50df7c2c7c9c9802d645f">pcs_reencrypt</a> (<a class="el" href="structpcs__public__key.html">pcs_public_key</a> *pk, <a class="el" href="structhcs__random.html">hcs_random</a> *hr, mpz_t rop, mpz_t op)</td></tr>
<tr class="memdesc:a65b3c0fb74b50df7c2c7c9c9802d645f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reencrypt an encrypted value <code>op</code>.  <a href="#a65b3c0fb74b50df7c2c7c9c9802d645f">More...</a><br /></td></tr>
<tr class="separator:a65b3c0fb74b50df7c2c7c9c9802d645f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac752fafb94995b91937f6866f301c028"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcs_8h.html#ac752fafb94995b91937f6866f301c028">pcs_ep_add</a> (<a class="el" href="structpcs__public__key.html">pcs_public_key</a> *pk, mpz_t rop, mpz_t cipher1, mpz_t plain1)</td></tr>
<tr class="memdesc:ac752fafb94995b91937f6866f301c028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a plaintext value <code>plain1</code> to an encrypted value <code>cipher1</code>, storing the result in <code>rop</code>.  <a href="#ac752fafb94995b91937f6866f301c028">More...</a><br /></td></tr>
<tr class="separator:ac752fafb94995b91937f6866f301c028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0df746eab238f2d5b4fa6932c0ed888"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcs_8h.html#ae0df746eab238f2d5b4fa6932c0ed888">pcs_ee_add</a> (<a class="el" href="structpcs__public__key.html">pcs_public_key</a> *pk, mpz_t rop, mpz_t cipher1, mpz_t cipher2)</td></tr>
<tr class="memdesc:ae0df746eab238f2d5b4fa6932c0ed888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an encrypted value <code>cipher2</code> to an encrypted value <code>cipher1</code>, storing the result in <code>rop</code>.  <a href="#ae0df746eab238f2d5b4fa6932c0ed888">More...</a><br /></td></tr>
<tr class="separator:ae0df746eab238f2d5b4fa6932c0ed888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1b4f9d7d5703d0b9da993878ec6758"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcs_8h.html#afd1b4f9d7d5703d0b9da993878ec6758">pcs_ep_mul</a> (<a class="el" href="structpcs__public__key.html">pcs_public_key</a> *pk, mpz_t rop, mpz_t cipher1, mpz_t plain1)</td></tr>
<tr class="memdesc:afd1b4f9d7d5703d0b9da993878ec6758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a plaintext value <code>plain1</code> with an encrypted value <code>cipher1</code>, storing the result in <code>rop</code>.  <a href="#afd1b4f9d7d5703d0b9da993878ec6758">More...</a><br /></td></tr>
<tr class="separator:afd1b4f9d7d5703d0b9da993878ec6758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199a1fd03186cb1a383a39afc0a7c284"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcs_8h.html#a199a1fd03186cb1a383a39afc0a7c284">pcs_decrypt</a> (<a class="el" href="structpcs__private__key.html">pcs_private_key</a> *vk, mpz_t rop, mpz_t cipher1)</td></tr>
<tr class="memdesc:a199a1fd03186cb1a383a39afc0a7c284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt a value <code>cipher1</code>, and set <code>rop</code> to the decrypted result.  <a href="#a199a1fd03186cb1a383a39afc0a7c284">More...</a><br /></td></tr>
<tr class="separator:a199a1fd03186cb1a383a39afc0a7c284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00df8635e442a24631dda3ca05cfb241"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcs_8h.html#a00df8635e442a24631dda3ca05cfb241">pcs_clear_public_key</a> (<a class="el" href="structpcs__public__key.html">pcs_public_key</a> *pk)</td></tr>
<tr class="memdesc:a00df8635e442a24631dda3ca05cfb241"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function zeros all data in <code>pk</code>.  <a href="#a00df8635e442a24631dda3ca05cfb241">More...</a><br /></td></tr>
<tr class="separator:a00df8635e442a24631dda3ca05cfb241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d2abc076923974a0112d99fbdfa741"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcs_8h.html#aa7d2abc076923974a0112d99fbdfa741">pcs_clear_private_key</a> (<a class="el" href="structpcs__private__key.html">pcs_private_key</a> *vk)</td></tr>
<tr class="memdesc:aa7d2abc076923974a0112d99fbdfa741"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function zeros all data in <code>pk</code>.  <a href="#aa7d2abc076923974a0112d99fbdfa741">More...</a><br /></td></tr>
<tr class="separator:aa7d2abc076923974a0112d99fbdfa741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0406c1f4406eb950c53fc5a8db3672b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcs_8h.html#a0406c1f4406eb950c53fc5a8db3672b2">pcs_free_public_key</a> (<a class="el" href="structpcs__public__key.html">pcs_public_key</a> *pk)</td></tr>
<tr class="memdesc:a0406c1f4406eb950c53fc5a8db3672b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a <a class="el" href="structpcs__public__key.html" title="Public key for use in the Paillier system. ">pcs_public_key</a> and all associated memory.  <a href="#a0406c1f4406eb950c53fc5a8db3672b2">More...</a><br /></td></tr>
<tr class="separator:a0406c1f4406eb950c53fc5a8db3672b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6929a2199aee7fd088e8596fa38920d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcs_8h.html#af6929a2199aee7fd088e8596fa38920d">pcs_free_private_key</a> (<a class="el" href="structpcs__private__key.html">pcs_private_key</a> *vk)</td></tr>
<tr class="memdesc:af6929a2199aee7fd088e8596fa38920d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a <a class="el" href="structpcs__private__key.html" title="Private key for use in the Paillier system. ">pcs_private_key</a> and all associated memory.  <a href="#af6929a2199aee7fd088e8596fa38920d">More...</a><br /></td></tr>
<tr class="separator:af6929a2199aee7fd088e8596fa38920d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54755d63a74912a45268307a4d950c4d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcs_8h.html#a54755d63a74912a45268307a4d950c4d">pcs_verify_key_pair</a> (<a class="el" href="structpcs__public__key.html">pcs_public_key</a> *pk, <a class="el" href="structpcs__private__key.html">pcs_private_key</a> *vk)</td></tr>
<tr class="memdesc:a54755d63a74912a45268307a4d950c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check certain values shared between public and private keys to ensure they indeed are pairs.  <a href="#a54755d63a74912a45268307a4d950c4d">More...</a><br /></td></tr>
<tr class="separator:a54755d63a74912a45268307a4d950c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedbf7991bd9965d53895065e97241afa"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcs_8h.html#aedbf7991bd9965d53895065e97241afa">pcs_export_public_key</a> (<a class="el" href="structpcs__public__key.html">pcs_public_key</a> *pk)</td></tr>
<tr class="memdesc:aedbf7991bd9965d53895065e97241afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export a public key as a string.  <a href="#aedbf7991bd9965d53895065e97241afa">More...</a><br /></td></tr>
<tr class="separator:aedbf7991bd9965d53895065e97241afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b2806febb12439d1569c4dcb35e384"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcs_8h.html#ae2b2806febb12439d1569c4dcb35e384">pcs_export_private_key</a> (<a class="el" href="structpcs__private__key.html">pcs_private_key</a> *vk)</td></tr>
<tr class="memdesc:ae2b2806febb12439d1569c4dcb35e384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export a private key as a string.  <a href="#ae2b2806febb12439d1569c4dcb35e384">More...</a><br /></td></tr>
<tr class="separator:ae2b2806febb12439d1569c4dcb35e384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec40103bbe33805df7f2c666bfc58b13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcs_8h.html#aec40103bbe33805df7f2c666bfc58b13">pcs_import_public_key</a> (<a class="el" href="structpcs__public__key.html">pcs_public_key</a> *pk, const char *json)</td></tr>
<tr class="memdesc:aec40103bbe33805df7f2c666bfc58b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import a public key from a string.  <a href="#aec40103bbe33805df7f2c666bfc58b13">More...</a><br /></td></tr>
<tr class="separator:aec40103bbe33805df7f2c666bfc58b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208848664608e4a90b910276ab49a61b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcs_8h.html#a208848664608e4a90b910276ab49a61b">pcs_import_private_key</a> (<a class="el" href="structpcs__private__key.html">pcs_private_key</a> *vk, const char *json)</td></tr>
<tr class="memdesc:a208848664608e4a90b910276ab49a61b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import a private key from a string.  <a href="#a208848664608e4a90b910276ab49a61b">More...</a><br /></td></tr>
<tr class="separator:a208848664608e4a90b910276ab49a61b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Paillier scheme is a scheme which provides homormorphic addition, and limited multiplication on encrypted data. </p>
<p>These can be summarised as:</p>
<div class="fragment"><div class="line">E(a + b) = <a class="code" href="pcs_8h.html#ae0df746eab238f2d5b4fa6932c0ed888">pcs_ee_add</a>(E(a), E(b));</div>
<div class="line">E(a + b) = <a class="code" href="pcs_8h.html#ac752fafb94995b91937f6866f301c028">pcs_ep_add</a>(E(a), b);</div>
<div class="line">E(a * b) = <a class="code" href="pcs_8h.html#afd1b4f9d7d5703d0b9da993878ec6758">pcs_ep_mul</a>(E(a), b);</div>
</div><!-- fragment --><p>All mpz_t values can be aliases unless otherwise stated. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a3035af644a94bda8ea01eb81a1781ba4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpcs__public__key.html">pcs_public_key</a>* pcs_init_public_key </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a <a class="el" href="structpcs__public__key.html" title="Public key for use in the Paillier system. ">pcs_public_key</a> and return a pointer to the newly created structure. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an initialised <a class="el" href="structpcs__public__key.html" title="Public key for use in the Paillier system. ">pcs_public_key</a>, NULL on allocation failure </dd></dl>

</div>
</div>
<a class="anchor" id="af4d620d36edbd87870d9ee42ed4f907e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpcs__private__key.html">pcs_private_key</a>* pcs_init_private_key </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a <a class="el" href="structpcs__private__key.html" title="Private key for use in the Paillier system. ">pcs_private_key</a> and return a pointer to the newly created structure. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an initialised <a class="el" href="structpcs__private__key.html" title="Private key for use in the Paillier system. ">pcs_private_key</a>, NULL on allocation failure </dd></dl>

</div>
</div>
<a class="anchor" id="aad6bbd4593663ba9dadd3fe7cafd0074"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcs_generate_key_pair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpcs__public__key.html">pcs_public_key</a> *&#160;</td>
          <td class="paramname"><em>pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcs__private__key.html">pcs_private_key</a> *&#160;</td>
          <td class="paramname"><em>vk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhcs__random.html">hcs_random</a> *&#160;</td>
          <td class="paramname"><em>hr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a key pair with modulus size <code>bits</code>. </p>
<p>It is required that <code>pk</code> and <code>vk</code> are initialised before calling this function. <code>pk</code> and <code>vk</code> are expected to not be NULL.</p>
<p>In practice the <code>bits</code> value should usually be greater than 2048 to ensure sufficient security.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;pcs_public_key *pk = pcs_init_public_key();</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;pcs_private_key *vk = pcs_init_private_key();</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;hcs_random = hcs_random_init();</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;pcs_generate_key(pk, vk, hr, 2048);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pk</td><td>A pointer to an initialised <a class="el" href="structpcs__public__key.html" title="Public key for use in the Paillier system. ">pcs_public_key</a> </td></tr>
    <tr><td class="paramname">vk</td><td>A pointer to an initialised <a class="el" href="structpcs__private__key.html" title="Private key for use in the Paillier system. ">pcs_private_key</a> </td></tr>
    <tr><td class="paramname">hr</td><td>A pointer to an initialised <a class="el" href="structhcs__random.html" title="Random state used by a number of cryptographic functions. ">hcs_random</a> type </td></tr>
    <tr><td class="paramname">bits</td><td>The number of bits for the modulus of the key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a12a417767dc3e6332b701e0391eabc13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcs_encrypt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpcs__public__key.html">pcs_public_key</a> *&#160;</td>
          <td class="paramname"><em>pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhcs__random.html">hcs_random</a> *&#160;</td>
          <td class="paramname"><em>hr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mpz_t&#160;</td>
          <td class="paramname"><em>rop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mpz_t&#160;</td>
          <td class="paramname"><em>plain1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encrypt a value <code>plain1</code>, and set <code>rop</code> to the encrypted result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pk</td><td>A pointer to an initialised <a class="el" href="structpcs__public__key.html" title="Public key for use in the Paillier system. ">pcs_public_key</a> </td></tr>
    <tr><td class="paramname">hr</td><td>A pointer to an initialised <a class="el" href="structhcs__random.html" title="Random state used by a number of cryptographic functions. ">hcs_random</a> type </td></tr>
    <tr><td class="paramname">rop</td><td>mpz_t where the encrypted result is stored </td></tr>
    <tr><td class="paramname">plain1</td><td>mpz_t to be encrypted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a20bd765e28b001cbaf059b1d2b677444"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcs_encrypt_r </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpcs__public__key.html">pcs_public_key</a> *&#160;</td>
          <td class="paramname"><em>pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mpz_t&#160;</td>
          <td class="paramname"><em>rop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mpz_t&#160;</td>
          <td class="paramname"><em>plain1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mpz_t&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encrypt a value <code>plain1</code>, and set <code>rop</code> to the encrypted result. </p>
<p>Do not randomly generate an r value, instead, use the given <code>r</code>. This is largely useless to a user, but is important for some zero-knowledge proofs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pk</td><td>A pointer to an initialised <a class="el" href="structpcs__public__key.html" title="Public key for use in the Paillier system. ">pcs_public_key</a> </td></tr>
    <tr><td class="paramname">rop</td><td>mpz_t where the encrypted result is stored </td></tr>
    <tr><td class="paramname">plain1</td><td>mpz_t to be encrypted </td></tr>
    <tr><td class="paramname">r</td><td>random mpz_t value to be used during encryption </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a65b3c0fb74b50df7c2c7c9c9802d645f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcs_reencrypt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpcs__public__key.html">pcs_public_key</a> *&#160;</td>
          <td class="paramname"><em>pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhcs__random.html">hcs_random</a> *&#160;</td>
          <td class="paramname"><em>hr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mpz_t&#160;</td>
          <td class="paramname"><em>rop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mpz_t&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reencrypt an encrypted value <code>op</code>. </p>
<p>Upon decryption, this newly encrypted value, <code>rop</code>, will retain the same value as <code>op</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pk</td><td>A pointer to an initialised <a class="el" href="structpcs__public__key.html" title="Public key for use in the Paillier system. ">pcs_public_key</a> </td></tr>
    <tr><td class="paramname">hr</td><td>A pointer to an initialised <a class="el" href="structhcs__random.html" title="Random state used by a number of cryptographic functions. ">hcs_random</a> type </td></tr>
    <tr><td class="paramname">rop</td><td>mpz_t where the newly encrypted value is stored </td></tr>
    <tr><td class="paramname">op</td><td>mpz_t to be reencrypted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac752fafb94995b91937f6866f301c028"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcs_ep_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpcs__public__key.html">pcs_public_key</a> *&#160;</td>
          <td class="paramname"><em>pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mpz_t&#160;</td>
          <td class="paramname"><em>rop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mpz_t&#160;</td>
          <td class="paramname"><em>cipher1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mpz_t&#160;</td>
          <td class="paramname"><em>plain1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a plaintext value <code>plain1</code> to an encrypted value <code>cipher1</code>, storing the result in <code>rop</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pk</td><td>A pointer to an initialised <a class="el" href="structpcs__public__key.html" title="Public key for use in the Paillier system. ">pcs_public_key</a> </td></tr>
    <tr><td class="paramname">rop</td><td>mpz_t where the newly encrypted value is stored </td></tr>
    <tr><td class="paramname">cipher1</td><td>mpz_t to be added together </td></tr>
    <tr><td class="paramname">plain1</td><td>mpz_t to be added together </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae0df746eab238f2d5b4fa6932c0ed888"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcs_ee_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpcs__public__key.html">pcs_public_key</a> *&#160;</td>
          <td class="paramname"><em>pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mpz_t&#160;</td>
          <td class="paramname"><em>rop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mpz_t&#160;</td>
          <td class="paramname"><em>cipher1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mpz_t&#160;</td>
          <td class="paramname"><em>cipher2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an encrypted value <code>cipher2</code> to an encrypted value <code>cipher1</code>, storing the result in <code>rop</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pk</td><td>A pointer to an initialised <a class="el" href="structpcs__public__key.html" title="Public key for use in the Paillier system. ">pcs_public_key</a>. </td></tr>
    <tr><td class="paramname">rop</td><td>mpz_t where the newly encrypted value is stored </td></tr>
    <tr><td class="paramname">cipher1</td><td>mpz_t to be added together </td></tr>
    <tr><td class="paramname">cipher2</td><td>mpz_t to be added together </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd1b4f9d7d5703d0b9da993878ec6758"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcs_ep_mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpcs__public__key.html">pcs_public_key</a> *&#160;</td>
          <td class="paramname"><em>pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mpz_t&#160;</td>
          <td class="paramname"><em>rop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mpz_t&#160;</td>
          <td class="paramname"><em>cipher1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mpz_t&#160;</td>
          <td class="paramname"><em>plain1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply a plaintext value <code>plain1</code> with an encrypted value <code>cipher1</code>, storing the result in <code>rop</code>. </p>
<p>All the parameters can be aliased, however, usually only <code>rop</code> and <code>cipher1</code> will be.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pk</td><td>A pointer to an initialised <a class="el" href="structpcs__public__key.html" title="Public key for use in the Paillier system. ">pcs_public_key</a>. </td></tr>
    <tr><td class="paramname">rop</td><td>mpz_t where the newly encrypted value is stored </td></tr>
    <tr><td class="paramname">cipher1</td><td>mpz_t to be multiplied together </td></tr>
    <tr><td class="paramname">plain1</td><td>mpz_t to be multiplied together </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a199a1fd03186cb1a383a39afc0a7c284"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcs_decrypt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpcs__private__key.html">pcs_private_key</a> *&#160;</td>
          <td class="paramname"><em>vk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mpz_t&#160;</td>
          <td class="paramname"><em>rop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mpz_t&#160;</td>
          <td class="paramname"><em>cipher1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrypt a value <code>cipher1</code>, and set <code>rop</code> to the decrypted result. </p>
<p><code>rop</code> and <code>cipher1</code> can aliases for the same mpz_t.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vk</td><td>A pointer to an initialised <a class="el" href="structpcs__private__key.html" title="Private key for use in the Paillier system. ">pcs_private_key</a> </td></tr>
    <tr><td class="paramname">rop</td><td>mpz_t where the decrypted result is stored </td></tr>
    <tr><td class="paramname">cipher1</td><td>mpz_t to be decrypted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a00df8635e442a24631dda3ca05cfb241"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcs_clear_public_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpcs__public__key.html">pcs_public_key</a> *&#160;</td>
          <td class="paramname"><em>pk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function zeros all data in <code>pk</code>. </p>
<p>It is useful to use if we wish to generate or import a new value for the given <a class="el" href="structpcs__public__key.html" title="Public key for use in the Paillier system. ">pcs_public_key</a> and want to safely ensure the old values are removed.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;// ... Initialised a key pk and done some work with it</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;pcs_clear_public_key(pk); // All data from old key is now gone</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;pcs_import_public_key(pk, &quot;public.key&quot;); // Safe to reuse this key</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pk</td><td>A pointer to an initialised <a class="el" href="structpcs__public__key.html" title="Public key for use in the Paillier system. ">pcs_public_key</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7d2abc076923974a0112d99fbdfa741"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcs_clear_private_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpcs__private__key.html">pcs_private_key</a> *&#160;</td>
          <td class="paramname"><em>vk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function zeros all data in <code>pk</code>. </p>
<p>It is useful to use if we wish to generate or import a new value for the given <a class="el" href="structpcs__private__key.html" title="Private key for use in the Paillier system. ">pcs_private_key</a> and want to safely ensure the old values are removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vk</td><td>A pointer to an initialised <a class="el" href="structpcs__private__key.html" title="Private key for use in the Paillier system. ">pcs_private_key</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0406c1f4406eb950c53fc5a8db3672b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcs_free_public_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpcs__public__key.html">pcs_public_key</a> *&#160;</td>
          <td class="paramname"><em>pk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a <a class="el" href="structpcs__public__key.html" title="Public key for use in the Paillier system. ">pcs_public_key</a> and all associated memory. </p>
<p>The key memory is not zeroed, so one must call pcs_clear_public_key if it is required. one does not need to call pcs_clear_public_key before using this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pk</td><td>A pointer to an initialised <a class="el" href="structpcs__public__key.html" title="Public key for use in the Paillier system. ">pcs_public_key</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af6929a2199aee7fd088e8596fa38920d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcs_free_private_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpcs__private__key.html">pcs_private_key</a> *&#160;</td>
          <td class="paramname"><em>vk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a <a class="el" href="structpcs__private__key.html" title="Private key for use in the Paillier system. ">pcs_private_key</a> and all associated memory. </p>
<p>The key memory is not zeroed, so one must call pcs_clear_private_key if it is required. one does not need to call pcs_clear_private_key before using this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vk</td><td>v pointer to an initialised <a class="el" href="structpcs__private__key.html" title="Private key for use in the Paillier system. ">pcs_private_key</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a54755d63a74912a45268307a4d950c4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcs_verify_key_pair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpcs__public__key.html">pcs_public_key</a> *&#160;</td>
          <td class="paramname"><em>pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcs__private__key.html">pcs_private_key</a> *&#160;</td>
          <td class="paramname"><em>vk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check certain values shared between public and private keys to ensure they indeed are pairs. </p>
<p>This checks only the n values, and assumes that the caller has not altered other internal values. If the caller has only interacted with the keys through the usual functions, then this should guarantee the keys are pairs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pk</td><td>A pointer to an initialised <a class="el" href="structpcs__public__key.html" title="Public key for use in the Paillier system. ">pcs_public_key</a> </td></tr>
    <tr><td class="paramname">vk</td><td>A pointer to an initialised <a class="el" href="structpcs__private__key.html" title="Private key for use in the Paillier system. ">pcs_private_key</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if keys are valid, else zero </dd></dl>

</div>
</div>
<a class="anchor" id="aedbf7991bd9965d53895065e97241afa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* pcs_export_public_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpcs__public__key.html">pcs_public_key</a> *&#160;</td>
          <td class="paramname"><em>pk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export a public key as a string. </p>
<p>We only store the minimum required values to restore the key. In this case, this is only the n value.</p>
<p>The format these strings export as is as a JSON object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pk</td><td>A pointer to an initialised <a class="el" href="structpcs__public__key.html" title="Public key for use in the Paillier system. ">pcs_public_key</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string representing the given key, else NULL on error </dd></dl>

</div>
</div>
<a class="anchor" id="ae2b2806febb12439d1569c4dcb35e384"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* pcs_export_private_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpcs__private__key.html">pcs_private_key</a> *&#160;</td>
          <td class="paramname"><em>vk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export a private key as a string. </p>
<p>We only store the minimum required values to restore the key. In this case, these are the p and q values. The remaining values are then computed from these on import.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vk</td><td>A pointer to an initialised <a class="el" href="structpcs__private__key.html" title="Private key for use in the Paillier system. ">pcs_private_key</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string representing the given key, else NULL on error </dd></dl>

</div>
</div>
<a class="anchor" id="aec40103bbe33805df7f2c666bfc58b13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcs_import_public_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpcs__public__key.html">pcs_public_key</a> *&#160;</td>
          <td class="paramname"><em>pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>json</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import a public key from a string. </p>
<p>The input string is expected to match the format given by the export functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pk</td><td>A pointer to an initialised <a class="el" href="structpcs__public__key.html" title="Public key for use in the Paillier system. ">pcs_public_key</a> </td></tr>
    <tr><td class="paramname">json</td><td>A string storing the contents of a public key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if success, else zero on format error </dd></dl>

</div>
</div>
<a class="anchor" id="a208848664608e4a90b910276ab49a61b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcs_import_private_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpcs__private__key.html">pcs_private_key</a> *&#160;</td>
          <td class="paramname"><em>vk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>json</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import a private key from a string. </p>
<p>The input string is expected to match the format given by the export functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vk</td><td>A pointer to an initialised <a class="el" href="structpcs__private__key.html" title="Private key for use in the Paillier system. ">pcs_private_key</a> </td></tr>
    <tr><td class="paramname">json</td><td>A string storing the contents of a private key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if success, else zero on format error </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Aug 29 2015 18:22:10 for libhcs by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
